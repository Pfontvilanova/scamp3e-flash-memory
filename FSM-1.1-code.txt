\ **************************************************************
\ *               SISTEMA DE FITXERS PER MEMORIA EXTERNA
\ *                     FLASHFORTH AMB SCAMP3e
\ *
\ *   ( File system manager for scamp3e external memory)
\**************************************************************
\ millora la visualitzacio de noms de fitxers i vocabularis

-fsm
marker -fsm


\ *************VOCABULARY MANAGER*************
\ vocabulary name, create a vocabulary
\ select name, select a vocabulary to work
\ v-list, list of all vocabularies
\ d-voc name, delete de vocabulary named
\ ***************VARIABLES*******************
variable current-vocab \ selected vocabulary
99 current-vocab ! \ 99 means no vocabulary active
variable add
variable len
create v-buffer 768 allot \ vocabulary table
 \ ** com que page te 256 bytes elbuffer ha de ser de 704 Bytes
 \ ** 14 x 32 + 256

: read-v-table
  15 0 do
        v-buffer ix 32 * + \ target
        ix page@  \ page un sector 0
       loop ;
: write-v-table
  15 0 do
        v-buffer ix 32 * + \ source
        ix page! \ page in sector 0
       loop ;
: erase-v-sector  
  dfUnlock dfWE 0 SectorErase ; \ erase sector 0
: v-sector-base ( index -- sector )
  32 * 32 + ; \ each voc starts at block 2, 3 ..
              \ 1 voc are two blocks = 128K
               \ voc0 are block 2-3, starts at sector 32
               \ block 0-1 spare
: vocabulary ( name -- ) \ create a vocabulary
    read-v-table 100 ms
    15 0 do \ search free space
         v-buffer ix 32 * + c@ 255 = if
             bl parse \ c-addr u
             v-buffer ix 32 * + place 10 ms \ copy name
             1 v-buffer ix 32 * + 16 + c! \ mark active
             ix v-buffer ix 32 * + 17 + c! \ mark index
             write-v-table 
             unloop exit
          else cr ." voc:" ix . ." occupied" 
          then 
       loop
  ." no space for more vocabularies" cr ;

: select ( name -- ) \ activate a vocabulary
    read-v-table
    bl parse over add ! len ! drop
  15 for
     v-buffer i 32 * + c@ 255 <> if
       add @ len @ v-buffer i 32 * + 1+ len @ compare 0= if
           i current-vocab !
           cr ." active vocabulary: " v-buffer i 32 * + count type cr
           rdrop exit
        then
      then
  next
  ." vocabulary not found" cr ;

: v-list \ list of vocabularies
  read-v-table
  ." vocabularies found: " cr
  15 0 do
     v-buffer ix 32 * + c@ 255 <> if
     v-buffer ix 32 * + count type cr
      then
  loop ;

: d-voc ( name -- ) \ erase a vocabulary
read-v-table
bl parse over add ! len ! drop
15 0 do
  v-buffer ix 32 * + c@ 255 <> if
   add @ len @ v-buffer ix 32 * + 1+ len @ compare 0= if 
   v-buffer ix 32 * + 32 255 fill \ erase voc with $ff
   erase-v-sector
   write-v-table
   ." vocabulary erased: " add @ len @ type cr unloop exit
   then
  then
loop ." voc not found" cr ;

: voc? ." the current vocabulary is: " current-vocab @ . ;


\ **************FILE SYSTEM MANAGER************************
\ 1 sector = 16 pages
\ 16 sectors = 1 block
\ 2 blocks = 1 vocabulary
\ vocabulary 0 starts at block 2, sector 32, page 512
\ to delete 1 sector, put the starting first page (old ff version)

\ ********************VARIABLES****************************
create f-buffer 256 allot \ 4KB for files
create f-table 768 allot \ 32 lines of 20 bytes
variable write? \ to know if save or not f-buffer
99 write? ! \ default
variable page-count \ number of pages per file
variable sector-base \ sector in vocabulary
variable buf-index \ position inside buffer
create provisbuf 16 allot \ temporal buffer
variable pb \ page were to search
create line-buf 64 allot       \ buffer for a 64 bytes line
variable byte-count            \ total of processed bytes
variable pagebase              \ page to read
variable pagecount             \ number of pages
0 value dfc                    \ byte from flash
variable bytes
variable flag
0 flag !
0 bytes !
variable lenb                   \ buffer length
0 lenb !

: erase-f-sector  
  dfUnlock dfWE 16 SectorErase ; \ erase sector 1
: write-f-table ( -- )
  dfUnlock dfWE 16 SectorErase \ erase sector 1
  f-table 16 page!  \ save ftable in sector 1
  f-table 256 + 17 page!
  f-table 512 + 18 page!
;

: read-f-table ( -- ) \ starts at page 16 
  f-table 16 page@
  f-table 256 + 17 page@
  f-table 512 + 18 page@
 ;
: nextfree-sector \ calculate the next sector free to write
  99 current-vocab @ = if ." select a vocabulary! " exit then
  read-f-table
  0 
  begin
    dup 32 < while \ file index
      dup 20 * f-table + c@ 255 = if
        current-vocab @ v-sector-base + \ free sector
        exit
      then
       1+
  repeat
  drop 0 ;

: create-f-table \ table with files information
  read-f-table \ read stored table
  32 0 do
     f-table ix 20 * + c@ 255 = if
        provisbuf 1+ len @ f-table ix 20 * + place \ save name
        current-vocab @ f-table ix 20 * + 16 + c! \ save vocab
        sector-base @ f-table ix 20 * + 17 + c! \ save sector
        page-count @ f-table ix 20 * + 18 + c! \ save n. page
        0 f-table ix 20 * + 19 + c! \ extra not used
        unloop exit
      then
      loop ." no space in f-table" cr ;


: >save ( name -- )
  provisbuf 16 erase 
  [char] 13 parse over add ! len ! drop
  add @ len @ provisbuf place 100 ms ;
 \ guarda el parse
: sb nextfree-sector sector-base ! \ free sector
  0 page-count !
  0 write? !
;
: save >save sb f-buffer 256 erase ; \ save the name of file

: -rot rot rot ;
: >= 2dup > -rot = or ;
  
: endfile-action
   page-count @ 0= if
         dfUnlock dfWE sector-base @ 16 * SectorErase \ erase sector
      then
         f-buffer sector-base @ 16 * page-count @ + page!
         page-count @ 1 + page-count !
         create-f-table
         write-f-table
         99 write? !
         0 buf-index !
         f-buffer 256 erase 
         exit   
;

: fullbuf-action
   page-count @ 0= if
         dfUnlock dfWE sector-base @ 16 * SectorErase \ erase sector
      then
       f-buffer sector-base @ 16 * page-count @ + page!
       page-count @ 1 + page-count !
       0 buf-index !
       0 write? !
       f-buffer 256 erase 
;

: { ( -- c-addr u) \ compile from text file
 0 buf-index !
 write? @ <> 0 if ." you need firts make save <name>" cr then
begin
  key dup [char] } = if drop
      2 write? ! 10 ms
  \ end of file
    else 
    f-buffer buf-index @ + c! \ fill f-buffer
    buf-index @ 1+ buf-index !
    buf-index @ 256 = if
       1 write? ! \ full buffer
       then
    then 5 ms
   write? @ 
    case
      1 of fullbuf-action endof \ when buffer is full
      2 of endfile-action endof \ when file is ended
    endcase
again ;

: f-list ( -- ) \ list all files in a vocabulary
  read-f-table
  cr ." files in active voc:" cr
  0
   32 0 do
    f-table ix 20 * + 16 + c@ current-vocab @ = if \ compara vocab
    f-table ix 20 * + count type cr \ muestra nombre (máx 16)
    1+
    then
  loop 
   ." found " . ." files" cr
;

: f-see ( name -- ) \ see a file code in vocabulary selected
  read-f-table
  bl parse over add ! len ! drop
  add @ len @ provisbuf place
  32 0 do
    f-table ix 20 * + c@ 255 <> if
      \ compara nombre y vocabulario
      provisbuf count f-table ix 20 * + 1+ len @ compare 0= 
      f-table ix 20 * + 16 + c@ current-vocab @ = and if
        \ encontrado: muestra contenido
        f-table ix 20 * + 17 + c@ \ sector base
        16 * \ sector a página base
        pb ! \ page were to search
        f-table ix 20 * + 18 + c@ \ número de páginas
        dup 0= if ." fichero vacío" cr drop unloop exit then
        0 do 
          f-buffer 256 erase
          f-buffer pb @ ix + page@ \ lee página base en f-buffer 
          f-buffer 256 type \ muestra contenido
        loop
        unloop exit
      then
    then
  loop
  ." File not found in active vocabulary" cr ;

: d-file ( name -- ) \ delete a file from delected vocabulary
  read-f-table
  bl parse over add ! len ! drop
  add @ len @ provisbuf place
  32 0 do
    f-table ix 20 * + c@ 255 <> if
      \ compara nombre y vocabulario activo
      provisbuf count f-table ix 20 * + 1+ len @ compare 0= 
      f-table ix 20 * + 16 + c@ current-vocab @ = and if
        \ encontrado: borra la entrada
        f-table ix 20 * + 20 255 fill \ rellena con $ff
        write-f-table
        ." fichero borrado: " provisbuf count type cr
        unloop exit
      then
    then
  loop
  ." File not found in active vocabulary" cr ;

: message
        cr ." File compiled successfully: "
        bytes @ . ." bytes processed" cr
        0 bytes !
;

: search-file ( name -- )
  \ search for a file in the file table
  read-f-table
  bl parse over add ! len ! drop
  add @ len @ provisbuf place
  f-table c@ 255 = if 
      ." File not found in active vocabulary" cr
  then 
  32 0 do
    f-table ix 20 * + c@ 255 <> if
      provisbuf count f-table ix 20 * + 1+ len @ compare 0 = 
      f-table ix 20 * + 16 + c@ current-vocab @ = and if
        \ file found
        f-table ix 20 * + 17 + c@           \ sector base
        16 * pagebase !            \ sector → page base
        f-table ix 20 * + 18 + c@          \ pages number
        pagecount !
      then
    then
loop
;

: printodd \ print and evaluate
  line-buf lenb @ type
  line-buf lenb @ evaluate 10 ms
  0 lenb ! line-buf 64 erase
;

: odd/even-action \ when cr is in odd position
  dfc 13 = byte-count @ 2 mod and if
         lenb @ bytes @ + bytes !  printodd
  else \ cr is in even position
           1 flag !
  then
;

: printeven \ print and evaluate
  line-buf lenb @ type
  line-buf lenb @ evaluate 10 ms
  0 flag ! 0 lenb ! line-buf 64 erase
;

: flag-action \ when cr is in even position
  flag @ 1 = if
           lenb @ bytes @ + bytes ! printeven
  then
;

: compile \ fill the line-buf and evaluate file
begin
 byte-count @ 256 /mod pagebase @ + swap dfc@ to dfc 
 pagecount @ 256 * byte-count @ >= while 
            byte-count @ 2 mod 0= if dfc line-buf lenb @ + 1+ c!
                                 lenb @ 1+ lenb ! 
                        else dfc line-buf lenb @ + 1- c!
                                 lenb @ 1+ lenb !
                        then
            dfc 13 = if
                     odd/even-action
            else
                     flag-action
            then
    byte-count @ 1+ byte-count !
repeat
;

: reset \ useful if some error happen
 0 flag ! 0 byte-count ! 0 lenb ! 0 bytes !
;

: include ( name -- )
  reset search-file compile message reset
;

: init 99 write? ! \ only first time installation
       99 current-vocab !
       erase-v-sector
       erase-f-sector
;


\ ****************FILES FOR TEST:****************
{
: measure
ticks >r
' execute
ticks r> - abs cr
." temps:" dup . ." milisegons" cr
0 <# # # # [char] . hold #s #> type ." segons"cr ;
}

{
ram create eval-buff 256 allot
: r| ( -- c-addr u)
 0
 begin
    dup
   key dup emit dup [char] | = invert while
   \ dup 13 = dup 10 = or  if
   \ drop 32 \ ja no cal.
   \ then
   swap eval-buff swap + c! 1+
   dup 256 = if exit then
 repeat
 drop drop eval-buff swap ;
}

{
: jumptable:   ( -- )   \ compile an execution table
              ( m -- ) \ execute a word corresponding to m
  flash                \ The jumptable goes into flash
  create
    here 0 dup ,       \ initial test_cnt stored at pfa
                       \ ( addr count -- )
  does>                \ ( m addr -- )
    dup @              \ ( m a cnt -- )
    for
      cell+            \ point to test value
      2dup @ =         \ ( m a flag -- )
      if
        endit          \ a match was found
      else
        cell+          \ ( m a' -- ) point to execution address
      then
    next
    nip cell+ @ex      \ execute the word
;

\ Use the words | and default| to fill jump table.
\
: |  ( addr count nn -- addr count )
  , ' ,              \ store m (match) and cfa in table
  1+                 \ increment count
;

: default| ( addr count -- )
  swap ! ' ,  ram   \ store default word cfa in table
;

ram
}

{
true value debug
: \\ debug invert if postpone \ then ; immediate
: debugon true to debug ;
: debugoff false to debug ;
}



