\ **************************************************************
\ *               SISTEMA DE FITCHERS PER MEMORIA EXTERNA
\ *                     FLASHFORTH AMB SCAMP3e
\ *
\ *   ( File system manager for scamp3e external memory)
\**************************************************************


-fsm
marker -fsm

: init 99 write? ! \ only first time installation
       99 current-vocab !
       erase-v-sector
       erase-f-sector
;
: reset \ useful if some error happen
 0 flag ! 0 byte-count ! 0 lenb ! 0 bytes !
;

\*************VOCABULARY MANAGER*************
\ vocabulary name, create a vocabulary
\ select name, select a vocabulary to work
\ v-list, list of all vocabularies
\ d-voc name, delete de vocabulary named
\ ***************VARIABLES*******************
variable current-vocab \ selected vocabulary
99 current-vocab ! \ 99 means no vocabulary active
variable add
variable len
create v-buffer 768 allot \ vocabulary table
 \ ** com que page te 256 bytes elbuffer ha de ser de 704 Bytes
 \ ** 14 x 32 + 256

: read-v-table
  15 0 do
        v-buffer ix 32 * + \ target
        ix page@  \ page un sector 0
       loop ;
: write-v-table
  15 0 do
        v-buffer ix 32 * + \ source
        ix page! \ page in sector 0
       loop ;
: erase-v-sector  
  dfUnlock dfWE 0 SectorErase ; \ erase sector 0
: v-sector-base ( index -- sector )
  32 * 32 + ; \ each voc starts at block 2, 3 ..
              \ 1 voc are two blocks = 128K
               \ voc0 are block 2-3, starts at sector 32
               \ block 0-1 spare
: vocabulary ( name -- ) \ create a vocabulary
    read-v-table 100 ms
    15 0 do \ search free space
         v-buffer ix 32 * + c@ 255 = if
             bl parse \ c-addr u
             v-buffer ix 32 * + swap cmove 10 ms \ copy name
             1 v-buffer ix 32 * + 16 + c! \ mark active
             ix v-buffer ix 32 * + 17 + c! \ mark index
             write-v-table 
           ( ix v-init ) unloop exit
                       else cr ." voc:" ix . ." occupied" cr 
                       then 
       loop
  ." no space for more vocabularies" cr ;

: select ( name -- ) \ activate a vocabulary
    read-v-table
    bl parse over add ! len ! drop
  15 for
     v-buffer i 32 * + c@ 255 <> if
       add @ len @ v-buffer i 32 * + len @ compare 0= if
           i current-vocab !
           cr ." active vocabulary: " v-buffer i 32 * + len @ type cr
           rdrop exit
        then
      then
  next
  ." vocabulary not found" cr ;

: v-list \ list of vocabularies
  read-v-table
  ." vocabularies found: " cr
  15 0 do
     v-buffer ix 32 * + c@ 255 <> if
     v-buffer ix 32 * + 16 type cr
      then
  loop ;

: d-voc ( name -- ) \ erase a vocabulary
read-v-table
bl parse over add ! len ! drop
15 0 do
  v-buffer ix 32 * + c@ 255 <> if
   add @ len @ v-buffer ix 32 * + len @ compare 0= if 
   v-buffer ix 32 * + 32 255 fill \ erase voc with $ff
   erase-v-sector
   write-v-table
   \ ix v-init
   ." vocabulary erased: " add @ len @ type cr unloop exit
   then
  then
loop ." voc not found" cr ;

: voc? ." the current vocabulary is: " current-vocab @ . ;


\ **************FILE SYSTEM MANAGER************************
\ 1 sector = 16 pages
\ 16 sectors = 1 block
\ 2 blocks = 1 vocabulary
\ vocabulary 0 starts at block 2, sector 32, page 512
\ to delete 1 sector, put the starting first page (old ff version)

\ ********************VARIABLES****************************
create f-buffer 256 allot \ 4KB for files
create f-table 768 allot \ 32 lines of 20 bytes
variable write? \ to know if save or not f-buffer
99 write? ! \ default
variable page-count \ number of pages per file
variable sector-base \ sector in vocabulary
variable buf-index \ position inside buffer
create provisbuf 16 allot \ temporal buffer
variable pb \ page were to search
create line-buf 64 allot       \ buffer for a 64 bytes line
variable byte-count            \ total of processed bytes
variable pagebase              \ page to read
variable pagecount             \ number of pages
0 value dfc                    \ byte from flash
variable bytes
variable flag
0 flag !
0 bytes !
variable lenb                   \ buffer length
0 lenb !

: erase-f-sector  
  dfUnlock dfWE 16 SectorErase ; \ erase sector 1
: write-f-table ( -- )
  dfUnlock dfWE 16 SectorErase \ erase sector 1
  f-table 16 page!  \ save ftable in sector 1
  f-table 256 + 17 page!
  f-table 512 + 18 page!
;

: read-f-table ( -- ) \ starts at page 16 
  f-table 16 page@
  f-table 256 + 17 page@
  f-table 512 + 18 page@
 ;
: nextfree-sector \ calculate the next sector free to write
  99 current-vocab @ = if ." select a vocabulary! " exit then
  read-f-table
  0 
  begin
    dup 32 < while \ file index
      dup 20 * f-table + c@ 255 = if
        current-vocab @ v-sector-base + \ free sector
        exit
      then
       1+
  repeat
  drop 0 ;

: create-f-table \ table with files information
  read-f-table \ read stored table
  32 0 do
     f-table ix 20 * + c@ 255 = if
        provisbuf f-table ix 20 * + len @ cmove \ save name
        current-vocab @ f-table ix 20 * + 16 + c! \ save vocab
        sector-base @ f-table ix 20 * + 17 + c! \ save sector
        page-count @ f-table ix 20 * + 18 + c! \ save n. page
        0 f-table ix 20 * + 19 + c! \ extra not used
        unloop exit
      then
      loop ." no space in f-table" cr ;


: >save ( name -- ) 
  [char] 13 parse over add ! len ! drop
  add @ len @ provisbuf swap cmove 100 ms ;
 \ guarda el parse
: sb nextfree-sector sector-base ! \ free sector
  0 page-count !
  0 write? !
;
: save >save sb f-buffer 256 erase ; \ save the name of file

: -rot rot rot ;
: >= 2dup > -rot = or ;
  
: endfile-action
   page-count @ 0= if
         dfUnlock dfWE sector-base @ 16 * SectorErase \ erase sector
      then
         f-buffer sector-base @ 16 * page-count @ + page!
         page-count @ 1 + page-count !
         create-f-table
         write-f-table
         99 write? !
         0 buf-index !
         f-buffer 256 erase 
         exit   
;

: fullbuf-action
   page-count @ 0= if
         dfUnlock dfWE sector-base @ 16 * SectorErase \ erase sector
      then
       f-buffer sector-base @ 16 * page-count @ + page!
       page-count @ 1 + page-count !
       0 buf-index !
       0 write? !
       f-buffer 256 erase 
;

: [[ ( -- c-addr u) \ compile from text file
 0 buf-index !
 write? @ <> 0 if ." you need firts make save <name>" cr then
begin
  key dup [char] ] = if drop
      2 write? !
  \ end of file
    else 
    f-buffer buf-index @ + c! \ fill f-buffer
    buf-index @ 1+ buf-index !
    buf-index @ 256 = if
       1 write? ! \ full buffer
       then
    then 10 ms
   write? @ 
    case
      1 of fullbuf-action endof \ when buffer is full
      2 of endfile-action endof \ when file is ended
    endcase
again ;

: f-list ( -- ) \ list all files in a vocabulary
  read-f-table
  cr ." files in active voc:" cr
  0
   32 0 do
    f-table ix 20 * + 16 + c@ current-vocab @ = if \ compara vocab
    f-table ix 20 * + 16 type cr \ muestra nombre (máx 16)
    1+
    then
  loop 
   ." found " . ." files" cr
;

: f-see ( name -- ) \ see a file code in vocabulary selected
  read-f-table
  bl parse over add ! len ! drop
  add @ len @ provisbuf swap cmove
  32 0 do
    f-table ix 20 * + c@ 255 <> if
      \ compara nombre y vocabulario
      provisbuf len @ f-table ix 20 * + len @ compare 0= 
      f-table ix 20 * + 16 + c@ current-vocab @ = and if
        \ encontrado: muestra contenido
        f-table ix 20 * + 17 + c@ \ sector base
        16 * \ sector a página base
        pb ! \ page were to search
        f-table ix 20 * + 18 + c@ \ número de páginas
        dup 0= if ." fichero vacío" cr drop unloop exit then
        0 do 
          f-buffer 256 erase
          f-buffer pb @ ix + page@ \ lee página base en f-buffer 
          f-buffer 256 type \ muestra contenido
        loop
        unloop exit
      then
    then
  loop
  ." File not found in active vocabulary" cr ;

: d-file ( name -- ) \ delete a file from delected vocabulary
  read-f-table
  bl parse over add ! len ! drop
  add @ len @ provisbuf swap cmove
  32 0 do
    f-table ix 20 * + c@ 255 <> if
      \ compara nombre y vocabulario activo
      provisbuf len @ f-table ix 20 * + len @ compare 0= 
      f-table ix 20 * + 16 + c@ current-vocab @ = and if
        \ encontrado: borra la entrada
        f-table ix 20 * + 20 255 fill \ rellena con $ff
        write-f-table
        ." fichero borrado: " provisbuf len @ type cr
        unloop exit
      then
    then
  loop
  ." File not found in active vocabulary" cr ;

: message
        cr ." File compiled successfully: "
        bytes @ . ." bytes processed" cr
        0 bytes !
;

: search-file ( name -- )
  \ search for a file in the file table
  read-f-table
  bl parse over add ! len ! drop
  add @ len @ provisbuf swap cmove
  f-table c@ 255 = if 
      ." File not found in active vocabulary" cr
  then 
  32 0 do
    f-table ix 20 * + c@ 255 <> if
      provisbuf len @ f-table ix 20 * + len @ compare 0 = 
      f-table ix 20 * + 16 + c@ current-vocab @ = and if
        \ file found
        f-table ix 20 * + 17 + c@           \ sector base
        16 * pagebase !            \ sector → page base
        f-table ix 20 * + 18 + c@          \ pages number
        pagecount !
      then
    then
loop
;

: printodd \ print and evaluate
  line-buf lenb @ type
  line-buf lenb @ evaluate 10 ms
  0 lenb ! line-buf 64 erase
;

: odd/even-action \ when cr is in odd position
  dfc 13 = byte-count @ 2 mod and if
         lenb @ bytes @ + bytes !  printodd
  else \ cr is in even position
           1 flag !
  then
;

: printeven \ print and evaluate
  line-buf lenb @ type
  line-buf lenb @ evaluate 10 ms
  0 flag ! 0 lenb ! line-buf 64 erase
;

: flag-action \ when cr is in even position
  flag @ 1 = if
           lenb @ bytes @ + bytes ! printeven
  then
;

: compile \ fill the line-buf and evaluate file
begin
 byte-count @ 256 /mod pagebase @ + swap dfc@ to dfc 
 pagecount @ 256 * byte-count @ >= while 
            byte-count @ 2 mod 0= if dfc line-buf lenb @ + 1+ c!
                                 lenb @ 1+ lenb ! 
                        else dfc line-buf lenb @ + 1- c!
                                 lenb @ 1+ lenb !
                        then
            dfc 13 = if
                     odd/even-action
            else
                     flag-action
            then
    byte-count @ 1+ byte-count !
repeat
;

: include ( name -- )
  reset search-file compile message reset
;


\ ****************FILES FOR TEST:****************


[[
: medir
ticks >r
' execute
ticks r> - abs cr
." temps:" dup . ." milisegons" cr
0 <# # # # 46 hold #s #> type ." segons"cr
;
]

[[
: .dec ( d n -- c-addr u )
base @ >r decimal
>r
2dup d0< >r
dabs
<#
  r@ 0 ?do
    10 um/mod
    48 + hold
        loop
  r@ 0 > if 46 hold then
  2dup d0= if 48 hold then
  #s
  r> if 45 hold then
#>
r> drop base ! ;
]


[[
: hola
." aixo es un fitxer de prova" ;
: adeu ." despedida" ;
hola
adeu
: final 1 2 3 . . . ." i punt" ;
final
]


[[
: qq ." primera proba" ;
qq
: fi ;
]

[[
: qq ." primera proba" ;
: tt ." segona prova" ;
S" ja va" cr type
]


[[
ram create bufr 256 allot
: t| ( -- c-addr u)
 0
 begin
    dup
   key dup emit dup 124 = invert while
   swap bufr swap + c! 1+
   dup 256 = if exit then
 repeat
 drop drop bufr swap ;
]

[[
: u.r+  0 swap <# 1- for # next #s #> type ;

\ Instruction Memory Dump.
\
: idump  ( addr +n -- )
   swap $fffe and         \ start on even address
   swap $10 u/ 1+         \ number of rows to print
\   dup 0= if drop 1 then \ Always print at least one line
   for
     cr dup 4 u.r+ [char] : emit space  \ display row addr
     $8                \ number of instructions per row
     for
       dup cf@ 2 u.r+ 4 u.r 2+  \ print 1 row of program space
     next
     $10 -             \ wind back the addr
     $8                \ number of instructions
     for               \ print ASCII
       dup cf@ swap drop
       over c@+ swap c@ rot
       3
       for
         >pr emit
       next 2+
     next
   next
   drop cr  ;
]

[[
: .dec ( d n -- c-addr u )
base @ >r decimal
>r
2dup d0< >r
dabs
<#
  r@ 0 ?do
    10 um/mod
    48 + hold
        loop
  r@ 0 > if 46 hold then
  2dup d0= if 48 hold then
  #s
  r> if 45 hold then
#>
r> drop base ! ;
: qq  \ posar mm al bufer "inter"
1 2 3 + + .
 ;
: hello ." hola" ;
hello
]

[[
: qq  \ posar mm al bufer "inter"
1 2 3 + + .
 ;
: hello ." hola" ;
hello
]






